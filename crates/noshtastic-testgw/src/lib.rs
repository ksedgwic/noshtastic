// Copyright (C) 2025 Bonsai Software, Inc.
// This file is part of Noshtastic, and is licensed under the
// GNU General Public License, version 3 or later. See the LICENSE file
// or <https://www.gnu.org/licenses/> for details.

use log::*;
use nostr_relay_pool::prelude::*;
use nostrdb::IngestMetadata;
use nostrdb::Ndb;
use std::time::Duration;
use tokio::task;

pub mod error;
pub use error::*;

pub struct TestGW {
    pub ndb: nostrdb::Ndb,
    pub opt_relay_url: Option<String>,
    pub opt_filter_json: Option<String>,
}

impl TestGW {
    pub fn new(
        ndb: Ndb,
        opt_relay_url: &Option<String>,
        opt_filter_json: &Option<String>,
    ) -> TestGWResult<Self> {
        Ok(TestGW {
            ndb,
            opt_relay_url: opt_relay_url.clone(),
            opt_filter_json: opt_filter_json.clone(),
        })
    }

    pub async fn start(&self) -> TestGWResult<()> {
        let url = match &self.opt_relay_url {
            Some(u) => u.as_str(),
            None => {
                info!("testgw relay not configured, skipping");
                return Ok(());
            }
        };

        let filter_json = match &self.opt_filter_json {
            Some(u) => u.as_str(),
            None => {
                info!("testgw filter not configured, skipping");
                return Ok(());
            }
        };

        // Initialize the relay pool (async Nostr relay manager)
        let pool = RelayPool::new();
        let relay_opts = RelayOptions::new()
            .retry_interval(Duration::from_secs(10))
            .read(true)
            .write(false);
        pool.add_relay(url, relay_opts).await?;
        pool.connect().await;

        let filter: nostr::Filter = serde_json::from_str(filter_json)?;
        use nostr_relay_pool::prelude::SubscribeOptions;
        let output = pool.subscribe(filter, SubscribeOptions::default()).await?;
        let sub_id = output.val; // subscription identifier generated by the pool
        debug!("Subscribed with ID: {}", sub_id);

        let ndb_handle = self.ndb.clone();
        task::spawn(async move {
            let mut notifications = pool.notifications();
            while let Ok(notification) = notifications.recv().await {
                if let nostr_relay_pool::RelayPoolNotification::Event {
                    subscription_id,
                    event,
                    ..
                } = notification
                {
                    // Serialize the event to JSON and format as a relay "EVENT" message
                    if let Ok(event_json) = serde_json::to_string(&event) {
                        let msg = format!(r#"["EVENT","{}",{}]"#, subscription_id, event_json);
                        // Insert the event into the database
                        if let Err(err) = ndb_handle
                            .process_event_with(msg.as_str(), IngestMetadata::new().client(false))
                        {
                            error!("ndb process_event_with failed: {}: {:?}", msg, err);
                        }
                    }
                }
            }
        });

        Ok(())
    }

    pub fn stop(&mut self) -> TestGWResult<()> {
        if self.opt_relay_url.is_some() && self.opt_filter_json.is_some() {
            info!(
                "testgw to {} stopping",
                self.opt_relay_url.as_ref().unwrap()
            );
        }
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    // use super::*;
    use nostrdb::Filter;
    use once_cell::sync::Lazy;

    static _INIT: Lazy<()> = Lazy::new(|| {
        env_logger::builder()
            .is_test(true)
            .filter_level(log::LevelFilter::Debug)
            .init();
    });

    #[test]
    fn test_ndb_filter_json() {
        let author_hexes = vec!["379e863e8357163b5bce5d2688dc4f1dcc2d505222fb8d74db600f30535dfdfe"];
        let authors: Vec<[u8; 32]> = author_hexes
            .into_iter()
            .map(|hex| {
                let decoded = hex::decode(hex).expect("valid hex string");
                decoded.try_into().expect("expected 32-byte array")
            })
            .collect();
        let filter = Filter::new().authors(authors.iter()).kinds([1]).build();
        dbg!(authors);
        assert_eq!(
            filter.json().unwrap(),
            r#"{"authors":["379e863e8357163b5bce5d2688dc4f1dcc2d505222fb8d74db600f30535dfdfe"],"kinds":[1]}"#
        );
    }
}
